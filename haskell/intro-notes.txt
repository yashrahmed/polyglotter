HASKELL NOTES from http://learnyouahaskell.com/

Using "stack" manager to install and manage haskell installations.

Please note that these notes sometimes use terminology from imperative programming.
This may lead to mis-representation of the concepts metioned herein. An effort has been
made to stick as close to functional programming paralance as possible.


Chapter 01: Starting out ---

-----Basics
1. Negative numbers are cannot simply be used in arithmetic operations e.g. 5 * -2. 
   Instead () need to be used in haskell expressions. This is because the interpreter gets confused b/w infix and prefix notation.
3. Expressions like 99 > 100 == True are problematic for the same reason. Correct way to use it is (99 > 100) == True.
3. Haskell is strongly typed.
4. Characters literals are written using '' and String using "".
5. In GHCI the 'let' keyword is used to define (not create) a variable. e.g. let a = 2.
   This is equivalent to doing a = 1 in the script. Use of let in GHCI is optional.

-----Operator Basics
5. There is no operator for "%". Instead Haskell has the operator `rem`.
6. != is represented as /=.

-----Function Basics
7. Function calls can be represented as (func param1 param2 ....)
8. Functions in a script can be defined in any order.
9. Functions and variables can have a quote (') in their name. By convention, Functions
   with ' at the end signify strict (as opposed to lazy evaluation) enabled.

-----If statements
10. Unlike other imperative programs, if statements are expressions than a depiction of control flow. Therefore an if statement must always have a then and an else.

-----Lists
11. Lists in Haskell must be homogeneous i.e. of the same type.
12. In Haskell strings like "yolo" are represented as ['y','o','l','o'].
13. List concatenation is done using the '++' operator.
14. An entry can be expressed as being a result of pre-fixing it using the : operator. E.g. t = 32:[1,2,3].
    This defines t as [32,1,2,3].
15. Elements of the list can be accessed using the !! operator. e.g. t !! 3. Unlike python -ve indices are not allowed.
16. Haskell indices are 0 based.
17. Lists within lists cannot be of different types but can be of different lengths.

-----Built in function for Lists.
18. Haskell defines some built in functions for elements of head.
      Let the list be defined (not created) as t = [1,2,3,4,5]
      Then :
         head t implies and evaluates to (not returns) 1
         tail t implies [2,3,4,5]
         init t implies [1,2,3,4]
         last t implies 5
         length t evaluates to 5
         reverese t evaluates to [5,4,3,2,1]
         null t evalautes to True if list is empty, False otherwise.
         take n t represents the first n (or less elements) of the list.
         drop n t is the opposite of take.
         minimum t and maximum t represent minimum and maximum elements respectively.
         product t and sum t represent the product and sum of elements in t respectively.
         head, tail, init, last throw exceptions when used on an empty list. 
         k `elem` t is used to express if element k is in list t.
19. In Haskell lists (like the variables) are defined and not created. This is apparent in an expression like
    t = [1,2,3] followed by t = 1:t. Unlike python where this would (with some changes) represent an element being inserted into a list, GHCI would simply evaluate the expression ad-infinitum as the definition of t is recursiveand unbounded. This behavior is not unlike what is observed in Prolog**.

-----Ranges
20. Haskell includes support for finite and infinite lists generated using ranges.
    [1..10] - Represents (and evaluates) to a list of 10 elements from 1 to 10 (inclusive).
    [1,2..10] - Represents interval [1,10] with step size of 1. The second element before .. is used to compute step size.
    [20,19..1] - Reverse lists require intermediary number to be specified. [20..1] evaluates to an empty list[].
    [1..] and [1,2..] represent infinite sequences. Haskell evaluates them lazily for e.g. the expression take 3 [1..] evaluates to [1,2,3].
    functions like cycle and repeat can represent infinite lists.
    replicate x k represents a list [x,x....k times].
21. Ranges also work with characters. Unicode characters produce some odd results for e.g.
    ['α'..'π'] evaluates to "\945\946\947\948\949\950\951\952\953\954\955\956\957\958\959\960".


-----List comprehensions
22. List comprehensions in Haskell are written using the following general expression
    [f(x) | x <- Domain, p1(x), p2(x),....pn(x)]
    where
      f is a function of x used to evaluate the output value.
      Domain is a list of values from which we can draw sample values for x.
      p1, p2,...pn are predicates which evaluate to True or False for a given value of x. ALL predicates must evaluate to True for x to be retained.
    Multiple variables are also allowed in Haskell similar to python. For e.g.
    [x + y | x <- [1..10], y <-[11..20], even x, odd y]. Like python '_' can be used to ignore the variables.

-----Tuples
23. Tuples work in a way similar to python. They have a finite number of values and can have values of different types e.g. ('Pizza Hut', 'Pepperoni', 10.99) is a valid tuple in Haskell. Haskell also considers a tuple as its own type. For e.g. (1,2) and (1,2,3) are tuples of different 'types', therefore a list [(1,2),(1,2,3)] cannot be represented is Haskell.
24. Haskell has two built in functions for tuples.
    fst -- represents first value
    snd -- represents second value
    These methods only work on doubles.
25. Singleton tuples are not allowed in Haskell. They are evaluated as an independent non-tuple value.
26. The zip function represents a list which contains tuples of corresponding elements of 2 lists. Unlike python zip does not evaluate for more than 2 lists.

Chapter 2: Types and Typeclasses ---

27. Haskell has a built in type-inference mechanism.
28. :t x represents the datatype of the value x. For e.g. :t 24 evaluates to 24 :: Num p => p. The symbol '=>' represents a class constraint. And the symbol '::' is read as 'has type of'. 
29. Explicit types in Haskell are represented by keywords with an uppercase first letter.
27. Strings are of type [Char].
28. Haskell (like Java 8 and above) also assigns type to functions. For e.g. :t cycle evaluates to [a] -> [a] i.e. it takes a list and returns a list. For functions with multiple arguments e.g. :t double_min which takes rwo arguments, Haskell evaluates the expression as double_min :: (Num a, Ord a) => a -> a -> a. There is no distinction made between the arguments and the return type. The last value is the return type.
29. Haskell built in types (including Prelude, which is a module included by default in all other modules) have the following types
    a. Char
    b. Float (single precision)
    c. Double (double precision)
    d. Bool.
    e. Int.
    f. Integer (Similar to BigInteger class in Java).
30. :t min evaluates to "min :: Ord a => a -> a -> a". In this result, 'a' is a Type variable (similar to Generics in Java) with a constraint that a be any type that is either Ord or its sub type.

-----Typeclasses
31. In Haskell all operators are functions. Any function with only special characters is considered an infix operator. The operator function must be wrapped within '()' to be used as a prefix (as is the case for regular functions) or when passed as arguments to other functions. For e.g. 2 + 3 and (+) 2 3 both evaluate to 5.
32. Also functions with 'normal' names can be used in infix forms using ``. For e.g. 2 `double_min` 3 and double_min 2 3 both evaluate to 4.
32. Operators like '==', '/=', '+', '-' etc are all functions. Expresson :t (+) evaluates to min :: Ord a => a -> a -> a.
33. Haskell Typeclasses are similar to Java interfaces that represent a certain type of behavior. Common typeclasses are described below -
    a. Eq - All subclasses of Eq must implement '=' and '/=' functions.
    b. Ord - Represents types that define partial or full order. It contains functions like >=, <=, > and <. Ord is a sub typeclass of Eq
    c. Show - Represent all typeclasses that can be represented as strings.
    d. Read - All classes that can be parsed from a string. The type constraint must be inferrable from the expression. For e.g. read "4" results in a parse failures since that could be interpreted as multiple ambiguous types. It could be an Int or a Char. An expression like read "3" + 4 is valid as Haskell can infer the type. 
    
    In order to represent a specific type the '::' symbol can be used. For e.g. read "3" :: Int evaluates to 3 while read "3" :: Float evalautes to 3.0. Note that '::' is NOT an operator. It is a 'keyword' used to represent the type.
    
    e. Enum - Typeclasses whose instances can be completely ordered. Some of the subclasses are Bool, Char, Int, Integer, Float, Double.
    f. Bounded - Typeclasses having an upper and a lower bound. minBound and maxBound methods can be used to check the bounds of any subclasses of Bounded. e.g. minBound :: Int yields -9223372036854775808. The sub-expression ':: Int' is also used to pass in type-variable arguments (Not sure about the mechanism!!!!1).
    g. Num - Represents numeric typeclasses like the one mentioned above. Some other special subclasses of Num are Integral (which provides whole number division and remainder operation support) and Floating (which encompasses Float and Double).
34. The typeclasses in Prelude 'implement' multiple typeclasses.

